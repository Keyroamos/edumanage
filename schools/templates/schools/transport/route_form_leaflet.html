<!-- Leaflet.js for maps (free, no API key required) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    let locationPickerMap;
    let locationPickerMarker;
    let currentField = null;
    let geocodeCache = {}; // Cache for geocoding results
    let searchTimeout = null;

    // Helper function to update form fields
    function updateLocationFields(field, lat, lng, address) {
        if (field === 'start') {
            const input = document.getElementById('start-location-input');
            if (input) input.value = address || '';
            const latField = document.getElementById('id_start_latitude');
            const lngField = document.getElementById('id_start_longitude');
            if (latField) latField.value = lat;
            if (lngField) lngField.value = lng;
        } else if (field === 'end') {
            const input = document.getElementById('end-location-input');
            if (input) input.value = address || '';
            const latField = document.getElementById('id_end_latitude');
            const lngField = document.getElementById('id_end_longitude');
            if (latField) latField.value = lat;
            if (lngField) lngField.value = lng;
        } else if (field === 'school') {
            const input = document.getElementById('school-location-input');
            if (input) input.value = address || '';
            const latField = document.getElementById('id_school_latitude');
            const lngField = document.getElementById('id_school_longitude');
            if (latField) latField.value = lat;
            if (lngField) lngField.value = lng;
        }
    }

    // Geocode address using Nominatim
    function geocodeAddress(address, callback) {
        if (!address || address.length < 3) {
            callback(null, null, null);
            return;
        }

        // Check cache first
        if (geocodeCache[address]) {
            const cached = geocodeCache[address];
            callback(cached.lat, cached.lng, cached.address);
            return;
        }

        // Call Nominatim API
        const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json&limit=1&addressdetails=1`;
        
        fetch(url, {
            headers: {
                'User-Agent': 'School Management System/1.0'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data && data.length > 0) {
                const result = data[0];
                const lat = parseFloat(result.lat);
                const lng = parseFloat(result.lon);
                const address = result.display_name;
                
                // Cache result
                geocodeCache[address] = { lat, lng, address };
                
                callback(lat, lng, address);
            } else {
                callback(null, null, null);
            }
        })
        .catch(error => {
            console.error('Geocoding error:', error);
            callback(null, null, null);
        });
    }

    // Reverse geocode coordinates to address
    function reverseGeocode(lat, lng, callback) {
        const cacheKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;
        
        if (geocodeCache[cacheKey]) {
            callback(geocodeCache[cacheKey]);
            return;
        }

        const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&addressdetails=1`;
        
        fetch(url, {
            headers: {
                'User-Agent': 'School Management System/1.0'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data && data.display_name) {
                const address = data.display_name;
                geocodeCache[cacheKey] = address;
                callback(address);
            } else {
                callback(`Location (${lat.toFixed(6)}, ${lng.toFixed(6)})`);
            }
        })
        .catch(error => {
            console.error('Reverse geocoding error:', error);
            callback(`Location (${lat.toFixed(6)}, ${lng.toFixed(6)})`);
        });
    }

    // Initialize address autocomplete
    function initializeAutocomplete() {
        const startInput = document.getElementById('start-location-input');
        const endInput = document.getElementById('end-location-input');
        const schoolInput = document.getElementById('school-location-input');

        // Create autocomplete for start location
        if (startInput) {
            let autocompleteList = null;
            startInput.addEventListener('input', function() {
                const query = this.value;
                if (query.length < 3) {
                    if (autocompleteList) autocompleteList.remove();
                    return;
                }

                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=5&addressdetails=1`;
                    
                    fetch(url, {
                        headers: { 'User-Agent': 'School Management System/1.0' }
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (autocompleteList) autocompleteList.remove();
                        
                        if (data && data.length > 0) {
                            autocompleteList = L.DomUtil.create('div', 'autocomplete-list', document.body);
                            autocompleteList.style.position = 'absolute';
                            autocompleteList.style.zIndex = '1000';
                            autocompleteList.style.backgroundColor = 'white';
                            autocompleteList.style.border = '1px solid #ccc';
                            autocompleteList.style.borderRadius = '4px';
                            autocompleteList.style.maxHeight = '200px';
                            autocompleteList.style.overflowY = 'auto';
                            
                            const rect = startInput.getBoundingClientRect();
                            autocompleteList.style.top = (rect.bottom + window.scrollY) + 'px';
                            autocompleteList.style.left = (rect.left + window.scrollX) + 'px';
                            autocompleteList.style.width = rect.width + 'px';

                            data.forEach(item => {
                                const option = L.DomUtil.create('div', 'autocomplete-item', autocompleteList);
                                option.style.padding = '8px';
                                option.style.cursor = 'pointer';
                                option.textContent = item.display_name;
                                option.addEventListener('mouseenter', () => {
                                    option.style.backgroundColor = '#f0f0f0';
                                });
                                option.addEventListener('mouseleave', () => {
                                    option.style.backgroundColor = 'white';
                                });
                                option.addEventListener('click', () => {
                                    startInput.value = item.display_name;
                                    document.getElementById('id_start_latitude').value = item.lat;
                                    document.getElementById('id_start_longitude').value = item.lon;
                                    if (autocompleteList) autocompleteList.remove();
                                    autocompleteList = null;
                                });
                            });
                        }
                    });
                }, 300);
            });

            // Close autocomplete when clicking outside
            document.addEventListener('click', function(e) {
                if (autocompleteList && !startInput.contains(e.target) && !autocompleteList.contains(e.target)) {
                    autocompleteList.remove();
                    autocompleteList = null;
                }
            });
        }

        // Similar for end and school inputs (simplified for brevity)
        // You can add similar code for endInput and schoolInput
    }

    function pickLocation(field) {
        currentField = field;
        const mapContainer = document.getElementById('location-picker-map');
        if (!mapContainer) {
            alert('Map container not found. Please refresh the page.');
            return;
        }

        mapContainer.style.display = 'block';

        // Initialize map if not already initialized
        if (!locationPickerMap) {
            locationPickerMap = L.map(mapContainer).setView([-1.2921, 36.8219], 13); // Nairobi default

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(locationPickerMap);

            // Add click listener
            locationPickerMap.on('click', function(e) {
                if (!currentField) return;

                const lat = e.latlng.lat;
                const lng = e.latlng.lng;

                // Update or create marker
                if (locationPickerMarker) {
                    locationPickerMarker.setLatLng([lat, lng]);
                } else {
                    locationPickerMarker = L.marker([lat, lng], { draggable: true }).addTo(locationPickerMap);
                    
                    // Add drag listener
                    locationPickerMarker.on('dragend', function(e) {
                        const pos = e.target.getLatLng();
                        reverseGeocode(pos.lat, pos.lng, function(address) {
                            updateLocationFields(currentField, pos.lat, pos.lng, address);
                        });
                    });
                }

                // Reverse geocode to get address
                reverseGeocode(lat, lng, function(address) {
                    updateLocationFields(currentField, lat, lng, address);
                });
            });
        }

        // Center map on existing location if available
        let existingLat = null;
        let existingLng = null;

        if (field === 'start') {
            const latField = document.getElementById('id_start_latitude');
            const lngField = document.getElementById('id_start_longitude');
            if (latField && latField.value) existingLat = parseFloat(latField.value);
            if (lngField && lngField.value) existingLng = parseFloat(lngField.value);
        } else if (field === 'end') {
            const latField = document.getElementById('id_end_latitude');
            const lngField = document.getElementById('id_end_longitude');
            if (latField && latField.value) existingLat = parseFloat(latField.value);
            if (lngField && lngField.value) existingLng = parseFloat(lngField.value);
        } else if (field === 'school') {
            const latField = document.getElementById('id_school_latitude');
            const lngField = document.getElementById('id_school_longitude');
            if (latField && latField.value) existingLat = parseFloat(latField.value);
            if (lngField && lngField.value) existingLng = parseFloat(lngField.value);
        }

        if (existingLat && existingLng && !isNaN(existingLat) && !isNaN(existingLng)) {
            locationPickerMap.setView([existingLat, existingLng], 15);
            if (locationPickerMarker) {
                locationPickerMarker.setLatLng([existingLat, existingLng]);
            } else {
                locationPickerMarker = L.marker([existingLat, existingLng], { draggable: true }).addTo(locationPickerMap);
                locationPickerMarker.on('dragend', function(e) {
                    const pos = e.target.getLatLng();
                    reverseGeocode(pos.lat, pos.lng, function(address) {
                        updateLocationFields(currentField, pos.lat, pos.lng, address);
                    });
                });
            }
        }

        // Scroll to map
        mapContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    // Initialize autocomplete when page loads
    document.addEventListener('DOMContentLoaded', function() {
        initializeAutocomplete();
    });
</script>

